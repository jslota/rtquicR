devtools::document()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools::document
devtools::document()
devtools::install()
devtools::install()
devtools::document()
devtools::install()
devtools::install()
devtools::document()
devtools::install()
devtools::install()
setwd("C:/Users/jslota/OneDrive - University of Manitoba/Research/Thesis projects/ReN prion infection model/RML infection ReN mmu/3rd attempt Feb 2020/Collections and QuIC results/analysis")
#' calculate 1/lag phase
#'
#' calculates the inverse lag phase for each well of the QuIC plate (AKA amyloid formation rate)
#'
#' @param data formatted RT-QuIC fluorescence data
#' @param sample_info Matrix that contains matching sample information for each well in the matching QuIC plate
#' @param cutoff The time cutoff in hours that will serve as the max time to reach threshold fluorescence
#' @param thresh_method The method for calculating threshold fluorescence. Default is StdDev (based on standard deviation). May also use 2xMean (2xmean(fluourescence)) or Max (10% of max fluorescence) or can manually specify a number.
#' @return Outputs a matrix with the 1/lag values for each well with matching sample info data
#' @export
calc_lag_phase <- function(data, sample_info, cutoff, thresh_method = "Manual", threshold) {
#cutoff time
data <- data[as.numeric(rownames(data)) < as.numeric(cutoff),]
if(thresh_method == "StdDev") {
#threshold = mean(negative controls) + 10 standard deviation
thresh <- as.numeric(mean(rowMeans(data)[1:4]) + 10*mean(apply(data, 1, sd)[1:4]))
} else if(thresh_method == "2xMean") {
thresh <- as.numeric(2*mean(rowMeans(data)[1:4]))
} else if(thresh_method == "Max") {
thresh <- as.numeric(mean(rowMeans(data)[1:4]) + 0.1*max(data))
} else if(thresh_method == "Manual") {
thresh <- threshold
}
#make data frame to collect time-points
time_data <- data.frame(Well = colnames(data), lag_time = 0)
#get first time-point above threshold
for (i in 1:ncol(data)) {
if (is.null(rownames(data[data[,i] > thresh,])) == FALSE) {
time_data$lag_time[i] <- as.numeric(rownames(data[data[,i] > thresh,])[1])
} else  {
time_data$lag_time[i] <- NA
}
}
#1/lag time
time_data$lag_time <- 1/time_data$lag_time
#Set negative wells to 1/lag = 0
time_data[is.na(time_data$lag_time),]$lag_time <- 0
#get sample info
time_data <- merge.data.frame(time_data, sample_info, by = "Well")
return(time_data)
}
devtools::install()
devtools::install()
install.package("devtools")
install.packages("devtools")
devtools::document()
devtools::document()
devtools::install()
install.packages("pracma")
devtools::document()
#' Convert time values
#'
#' Converts time values from a funky string of text to proper numerical values in hours.
#' Used by the load_quic_results() function
#'
#' @param QuIC_data formatted QuIC results matrix with funky time values
#' @return Matrix with proper numerical values for time in hours
time_fun <- function(QuIC_data) {
QuIC_data$Time <- 0
for (i in rownames(QuIC_data)) {
if (length(strsplit(rownames(QuIC_data[i,]), " ")[[1]]) < 3) {
QuIC_data[i,]$Time <- as.numeric(strsplit(rownames(QuIC_data[i,]), " ")[[1]][1])
} else {
QuIC_data[i,]$Time <- as.numeric(strsplit(rownames(QuIC_data[i,]), " ")[[1]][1]) + as.numeric(strsplit(rownames(QuIC_data[i,]), " ")[[1]][3])/60
}
}
rownames(QuIC_data) <- QuIC_data$Time
rownames(QuIC_data)
QuIC_data <- QuIC_data[,colnames(QuIC_data) != "Time"]
return(QuIC_data)
}
#' Load and format data frame
#'
#' Takes raw data and formats it for further analysis
#'
#' @param input_file the path to the file containing raw RT-QuIC fluorescence data values
#' @return Properly formatted matrix of QuIC data
#' @export
load_quic_results <- function(input_file) {
res <- as.data.frame(readxl::read_excel(input_file))
rownames(res) <- res[,1]
res <- as.data.frame(t(res[,-1]))
res <- time_fun(res)
return(res)
}
#' Format data for signal curve plot
#'
#' Takes matrix of QuIC fluorescence values and formats it with sample info to plot signal against time with ggplot
#' @param plot_data The formatted QuIC fluorescence data that will be used for plotting
#' @param plot_samples Matrix that contains matching sample information for each well in the matching QuIC plate
#' @param normalize Whether or not to normalize to %Max fluorescence
#' @return Formatted matrix of fluorescence for each well with sample info for signal curve plotting
#' @export
signal_curve <- function(plot_data, plot_samples, normalize = FALSE) {
if (normalize == TRUE) {
plot_data <- 100*(plot_data - min(plot_data))/(max(plot_data) - min(plot_data))
}
#format data for plotting
plot_data$time <- rownames(plot_data)
plot_data <- reshape2::melt(plot_data, id.vars = "time")
colnames(plot_data) <- c("Time", "Well", "Signal")
#convert time to numeric
plot_data$Time <- as.numeric(plot_data$Time)
###add sample info
plot_data <- merge.data.frame(plot_data, plot_samples, by = "Well")
return(plot_data)
}
#' generic signal curve plot
#'
#' makes a generic plot with ggplot from the formatted signal curve plot data
#'
#' @param plot_data output of signal_curve() function
#' @export
plot_signal_curve <- function(plot_data) {
cols <- RColorBrewer::brewer.pal(n = length(levels(as.factor(plot_data$Dilution))), name = "Set3")
#make plot
ggplot2::ggplot(plot_data, aes(x= Time, y = Signal, group = Well, color = as.factor(Dilution))) +
geom_line() +
scale_color_manual(values = cols) +
facet_wrap(~Sample, ncol = 2, dir = "v") +
theme(panel.background = element_rect(fill = "white"),
strip.background = element_rect(fill = "white"),
axis.line = element_line(colour = "black"),
panel.grid.major = element_line(color = "grey80"),
panel.grid.minor = element_line(color = "grey92"),
legend.position = "bottom",
legend.key = element_rect(fill = "white", colour = "black"))
}
#' calculate 1/lag phase
#'
#' calculates the inverse lag phase for each well of the QuIC plate (AKA amyloid formation rate)
#'
#' @param data formatted RT-QuIC fluorescence data
#' @param sample_info Matrix that contains matching sample information for each well in the matching QuIC plate
#' @param cutoff The time cutoff in hours that will serve as the max time to reach threshold fluorescence
#' @param thresh_method The method for calculating threshold fluorescence. Default is StdDev (based on standard deviation). May also use 2xMean (2xmean(fluourescence)) or Max (10% of max fluorescence) or can manually specify a number.
#' @return Outputs a matrix with the 1/lag values for each well with matching sample info data
#' @export
calc_lag_phase <- function(data, sample_info, cutoff, thresh_method = "StdDev", threshold) {
#cutoff time
data <- data[as.numeric(rownames(data)) < as.numeric(cutoff),]
if(thresh_method == "StdDev") {
#threshold = mean(negative controls) + 10 standard deviation
thresh <- as.numeric(mean(rowMeans(data)[1:4]) + 10*mean(apply(data, 1, sd)[1:4]))
} else if(thresh_method == "2xMean") {
thresh <- as.numeric(2*mean(rowMeans(data)[1:4]))
} else if(thresh_method == "Max") {
thresh <- as.numeric(mean(rowMeans(data)[1:4]) + 0.1*max(data))
} else if(thresh_method == "Manual") {
thresh <- threshold
}
#make data frame to collect time-points
time_data <- data.frame(Well = colnames(data), lag_time = 0)
#get first time-point above threshold
for (i in 1:ncol(data)) {
if (is.null(rownames(data[data[,i] > thresh,])) == FALSE) {
time_data$lag_time[i] <- as.numeric(rownames(data[data[,i] > thresh,])[1])
} else  {
time_data$lag_time[i] <- NA
}
}
#1/lag time
time_data$lag_time <- 1/time_data$lag_time
#Set negative wells to 1/lag = 0
time_data[is.na(time_data$lag_time),]$lag_time <- 0
#get sample info
time_data <- merge.data.frame(time_data, sample_info, by = "Well")
return(time_data)
}
#' generic plot of lag phase data
#'
#' Makes a generic plot of lag phase data for each QuIC plate
#'
#' @param lag_data Output of calc_lag_phase() function
#' @export
plot_lag_phase <- function(lag_data) {
cols <- RColorBrewer::brewer.pal(n = length(levels(as.factor(lag_data$Dilution))), name = "Set3")
ggplot2::ggplot(rev(lag_data), aes(x=as.factor(Dilution), y=lag_time, color=as.factor(Dilution))) +
geom_boxplot(color = "black", outlier.color = "white") +
geom_jitter(size = 2, width = 0.15) +
scale_color_manual(values = cols) +
xlab("Dilution") +
ylab("(lag phase)-1") +
facet_wrap(~Sample, scales = "free_x") +
theme(panel.background = element_rect(fill = "white"),
axis.text.x = element_text(angle = 90),
axis.line = element_line(color = "black"),
legend.position = "bottom",
legend.title = element_blank(),
legend.key = element_rect(fill = "white"),
legend.margin = margin(-0.3,0,0,0, "cm"))
}
#' calculate SD50 values
#'
#' Calculates SD50 for each sample from the lag phase data. 3/4 wells for the highest dilution must be
#' positive for the function to return SD50 measurements (This serves as the limit of detection).
#' Otherwise returns the maximum possible value below the limit of detection.
#'
#' @param lag_data Output of calc_lag_phase() function
#' @return Outputs SD50 values for each sample with matching sample info
#' @export
calc_SD50 <- function(lag_data) {
#setup output data frame
keep <- is.element(colnames(lag_data), c("Well", "lag_time", "Dilution")) == FALSE
sd50_res <- lag_data[,keep]
sd50_res <- unique(sd50_res)
rownames(sd50_res) <- sd50_res$Sample
sd50_res$SD50 <- 0
#calculate SD50 for each sample
for (i in unique(lag_data$Sample)) {
tmp <- lag_data[lag_data$Sample == i,]
#Calculate x0 (lowest dilution to be 4/4 positive)
dilutions = unique(tmp$Dilution)
x0 = 0
for (j in 1:length(dilutions)) {
if(sum(tmp[tmp$Dilution == dilutions[j],]$lag_time > 0) == 4) {
x0 <- -log10(dilutions[j])
}
}
if (x0 == 0) {
x0 <- -log10(10*max(dilutions))
}
#Remove false positives, need at least 3/4 50ng rxns to be positive
if (sum(tmp[tmp$Dilution == max(tmp$Dilution),]$lag_time > 0) < 3) {
tmp$lag_time <- 0
}
ni <- nrow(tmp)/length(unique(tmp$Dilution))
#Remove dilutions higher than x0
tmp <- tmp[tmp$Dilution <= 1.01*10^(-x0),] #the 1.01 factor is just to make sure the x0 dilution is included
ri <- sum(tmp$lag_time > 0)
sd50_res[i,]$SD50 <- (x0 - 1/2 + 1*(ri/ni))
rm(tmp)
}
return(sd50_res)
}
#' calculate AUC values
#'
#' Calculates lag phase AUC for each sample from the lag phase data. Converts dilution to -log10(dilution) for AUC calculation
#'
#' @param lag_data Output of calc_lag_phase() function
#' @return Outputs AUC values for each sample with matching sample info
#' @export
calc_AUC <- function(lag_data) {
per_sample_data <- lag_data
per_sample_data <- per_sample_data[per_sample_data$lag_time != Inf,]
per_sample_data$Dilution <- -log10(per_sample_data$Dilution)
per_sample_data <- aggregate(lag_time ~ Dilution+Sample, per_sample_data, mean)
#Make dataframe for AUC results
AUC_res <- lag_data[,-c(1,2,4)]
AUC_res <- unique(AUC_res)
rownames(AUC_res) <- AUC_res$Sample
AUC_res$AUC <- 0
#get AUC values
for (i in unique(per_sample_data$Sample)) {
tmp <- per_sample_data[per_sample_data$Sample == i,]
AUC_res[AUC_res$Sample == i,]$AUC <- pracma::trapz(x=tmp$Dilution, y=tmp$lag_time)
rm(tmp)
}
return(AUC_res)
}
devtools:document()
devtools::document()
devtools::sintall()
update(rlang)
update.packages(rlang)
devtools::document()
devtools::install()
devtools::install()
devtools::install()
devtools::install()
devtools
devtools::build()
devtools::document()
devtools::build()
devtools::build()
print("Error... incorrect value for 'file_type'")
devtools::document()
devtools::build()
devtools::build()
devtools::build()
devtools::build()
devtools::build()
devtools::build()
devtools::build()
devtools::document()
devtools::build()
kk
devtools::build()
devtools::build()
install.packages("devtools")
devtools::document()
devtools::build()
devtools::build()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::build()
devtools::build()
devtools::build()
devtools::document()
devtools::build()
devtools::document()
devtools::build()
devtools::build()
